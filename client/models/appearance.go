// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Appearance Appearance
//
// # An Appearance holds the values of the branding configuration, which are rendered across an organization
//
// swagger:model Appearance
type Appearance struct {

	// canonical
	// Required: true
	// Max Length: 100
	// Min Length: 1
	// Pattern: ^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$
	Canonical *string `json:"canonical"`

	// color
	// Required: true
	Color *AppearanceColor `json:"color"`

	// created at
	// Minimum: 0
	CreatedAt *uint64 `json:"created_at,omitempty"`

	// display name
	// Required: true
	// Max Length: 50
	// Min Length: 1
	DisplayName *string `json:"display_name"`

	// favicon
	// Required: true
	// Format: uri
	Favicon *strfmt.URI `json:"favicon"`

	// footer
	// Required: true
	// Max Length: 1000
	// Min Length: 0
	Footer *string `json:"footer"`

	// is active
	IsActive bool `json:"is_active,omitempty"`

	// logo
	// Required: true
	// Format: uri
	Logo *strfmt.URI `json:"logo"`

	// name
	// Required: true
	// Max Length: 50
	// Min Length: 1
	Name *string `json:"name"`

	// tab title
	// Required: true
	// Max Length: 50
	// Min Length: 1
	TabTitle *string `json:"tab_title"`

	// updated at
	// Minimum: 0
	UpdatedAt *uint64 `json:"updated_at,omitempty"`
}

// Validate validates this appearance
func (m *Appearance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCanonical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFavicon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFooter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTabTitle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Appearance) validateCanonical(formats strfmt.Registry) error {

	if err := validate.Required("canonical", "body", m.Canonical); err != nil {
		return err
	}

	if err := validate.MinLength("canonical", "body", *m.Canonical, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("canonical", "body", *m.Canonical, 100); err != nil {
		return err
	}

	if err := validate.Pattern("canonical", "body", *m.Canonical, `^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$`); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateColor(formats strfmt.Registry) error {

	if err := validate.Required("color", "body", m.Color); err != nil {
		return err
	}

	if m.Color != nil {
		if err := m.Color.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("color")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("color")
			}
			return err
		}
	}

	return nil
}

func (m *Appearance) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.MinimumUint("created_at", "body", *m.CreatedAt, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("display_name", "body", m.DisplayName); err != nil {
		return err
	}

	if err := validate.MinLength("display_name", "body", *m.DisplayName, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("display_name", "body", *m.DisplayName, 50); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateFavicon(formats strfmt.Registry) error {

	if err := validate.Required("favicon", "body", m.Favicon); err != nil {
		return err
	}

	if err := validate.FormatOf("favicon", "body", "uri", m.Favicon.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateFooter(formats strfmt.Registry) error {

	if err := validate.Required("footer", "body", m.Footer); err != nil {
		return err
	}

	if err := validate.MinLength("footer", "body", *m.Footer, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("footer", "body", *m.Footer, 1000); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateLogo(formats strfmt.Registry) error {

	if err := validate.Required("logo", "body", m.Logo); err != nil {
		return err
	}

	if err := validate.FormatOf("logo", "body", "uri", m.Logo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 50); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateTabTitle(formats strfmt.Registry) error {

	if err := validate.Required("tab_title", "body", m.TabTitle); err != nil {
		return err
	}

	if err := validate.MinLength("tab_title", "body", *m.TabTitle, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("tab_title", "body", *m.TabTitle, 50); err != nil {
		return err
	}

	return nil
}

func (m *Appearance) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.MinimumUint("updated_at", "body", *m.UpdatedAt, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this appearance based on the context it is used
func (m *Appearance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateColor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Appearance) contextValidateColor(ctx context.Context, formats strfmt.Registry) error {

	if m.Color != nil {

		if err := m.Color.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("color")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("color")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Appearance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Appearance) UnmarshalBinary(b []byte) error {
	var res Appearance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AppearanceColor appearance color
//
// swagger:model AppearanceColor
type AppearanceColor struct {

	// Blue color value of the RGB color
	// Required: true
	// Maximum: 255
	// Minimum: 0
	B *uint32 `json:"b"`

	// Green color value of the RGB color
	// Required: true
	// Maximum: 255
	// Minimum: 0
	G *uint32 `json:"g"`

	// Red color value of the RGB color
	// Required: true
	// Maximum: 255
	// Minimum: 0
	R *uint32 `json:"r"`
}

// Validate validates this appearance color
func (m *AppearanceColor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateB(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateG(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateR(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AppearanceColor) validateB(formats strfmt.Registry) error {

	if err := validate.Required("color"+"."+"b", "body", m.B); err != nil {
		return err
	}

	if err := validate.MinimumUint("color"+"."+"b", "body", uint64(*m.B), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumUint("color"+"."+"b", "body", uint64(*m.B), 255, false); err != nil {
		return err
	}

	return nil
}

func (m *AppearanceColor) validateG(formats strfmt.Registry) error {

	if err := validate.Required("color"+"."+"g", "body", m.G); err != nil {
		return err
	}

	if err := validate.MinimumUint("color"+"."+"g", "body", uint64(*m.G), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumUint("color"+"."+"g", "body", uint64(*m.G), 255, false); err != nil {
		return err
	}

	return nil
}

func (m *AppearanceColor) validateR(formats strfmt.Registry) error {

	if err := validate.Required("color"+"."+"r", "body", m.R); err != nil {
		return err
	}

	if err := validate.MinimumUint("color"+"."+"r", "body", uint64(*m.R), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumUint("color"+"."+"r", "body", uint64(*m.R), 255, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this appearance color based on context it is used
func (m *AppearanceColor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AppearanceColor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AppearanceColor) UnmarshalBinary(b []byte) error {
	var res AppearanceColor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
