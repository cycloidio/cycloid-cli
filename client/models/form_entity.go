// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FormEntity Forms file's Entity
//
// # This describes all the attributes possible to configure a form's variable
//
// swagger:model FormEntity
type FormEntity struct {

	// The current value that was previously configured for this variable upon creation or update. In case of shared variables having different values, it will be empty, and 'mismatch_values' will be filled instead.
	Current any `json:"current,omitempty"`

	// Default can take 2 kinds of definition.
	// The first one is simply the variable to assign if nothing is given by the user and that the variable is required.
	// The second one is dynamic default, meaning default that can vary based on conditions. The format is as follows:
	//   options:
	//     - name: "Name of set (can be omitted)"
	//       condition: "$env == 'dev'"
	//       default: t2.micro
	//     - condition: "$env == 'prod'"
	//       default: t2.large
	Default any `json:"default,omitempty"`

	// List of keys that are required to use this entity
	DependsOn []string `json:"depends_on"`

	// The description helping users understand the interest/impact of such variable/change
	Description string `json:"description,omitempty"`

	// Whether or not the entity should be displayed to the user. This entity must be usable as such (not required, or with a default if required)
	Folded bool `json:"folded,omitempty"`

	// The key is the name of variables for the ansible/pipeline/terraform technologies. If this is a first level variable then: keyX. If you have multiple terraform modules then use: module.Y.keyX to help identify the unique variable.
	// Required: true
	Key *string `json:"key"`

	// This is filled only when a shared variable does not have the same values anymore. e.g. a variable 'foo' was shared between 'ansible' and 'pipeline', was set to 'bar', but now the value found for 'ansible' is 'bus', while it's still 'bar' for the pipeline. In such situation, the Forms don't know anymore which is the correct data and will return both, while unsetting the 'Current' field.
	MismatchValues []any `json:"mismatch_values"`

	// The name of the variable displayed to the user
	// Required: true
	Name *string `json:"name"`

	// Whether or not the field is required - that helps distinguish "optional" variables and allows to set default if necessary and present
	Required bool `json:"required,omitempty"`

	// The source is only used for the branch widget to reference the key of the SCS or CR that the branches have to be read from. Because a branch in itself cannot exist, the user has to indicate from which SCS or CR he wants to retrieve branches. The source has to reference the key of an entity of a widget: 'CyCRS' or 'CySCS'
	Source string `json:"source,omitempty"`

	// The type of data handled - used to manipulate/validate the input, and also validate default/values
	// Required: true
	// Enum: ["integer","float","string","array","boolean","map"]
	Type *string `json:"type"`

	// The unit to be displayed for the variable, helping to know what's being manipulated: amount of servers, Go, users, etc.
	Unit string `json:"unit,omitempty"`

	// An array of validations and relative errors for this entitiy.  For example:
	//   validations:
	//     - regexp: "^proj_.*$"
	//       error_message: "the value must have 'proj_' as prefix"
	//     - regexp: "^.*_awesome$"
	//       error_message: "the value must have '_awesome' as suffix"
	// At the moment only regexp validations are implemented but  we can expect objects with a 'type', and 'error_message' field. The type field can hold the constraint, as in the case of regexp or  hipotetically a moe complex object.
	Validations []any `json:"validations"`

	// Values can take 2 kinds of definition.
	// First one is a list of object, such as list of integer, maps, etc. Values allowed, e.g. [1, 10, 20, 50]. Note: In case of SliderRange only 2 values should be provided: [min, max], in case of providing them the other way around some validation test will fail.
	// Second one is dynamic values, meaning values that can vary based on conditions. The format is as follows:
	//   options:
	//     - name: "Name of set (can be omitted)"
	//       condition: "$env == 'dev'"
	//       values: [dev-ami1, dev-ami2, dev-ami3]
	//     - condition: "$env == 'prod'"
	//       values: [prod-ami1, prod-ami2, prod-ami3]
	Values any `json:"values,omitempty"`

	// It's a URL in which the values have to be fetched from
	ValuesRef string `json:"values_ref,omitempty"`

	// The widget used to display the data in the most suitable way
	// Required: true
	// Enum: ["auto_complete","dropdown","radios","slider_list","slider_range","number","simple_text","switch","text_area","cy_cred","cy_scs","cy_crs","cy_branch","cy_inventory_resource","cy_inventory_output","hidden"]
	Widget *string `json:"widget"`

	// Some specific configuration that could be applied to that widget. Currently only a few widgets can be configured:
	//   * cy_cred
	//     * 'cred_types' (list): reduce the types of credentials retrieved to that list. See supported types of credentials
	//     * 'display_keys' (bool): to specify if the path + key have to be written or only the path
	//     * 'format' (enum): credential format, one of: 'path' | 'uri'. Defaults to path. Only credentials in URI format can be shared between technologies.
	//     * 'uri_parameters' (map): optional query parameters that should be encoded and added to the resulting credential URI by the client. For example, they may be used to specify the output format (e.g., JSON). Applies only if format='uri'.
	//   * radio
	//     * 'orientation' (string): whether you want to display it in an 'horizontal' or 'vertical' way
	//   * cy_inventory_resource
	//     * 'attribute' (string): REQUIRED The path to the attribute to actually use as value
	//     * 'filters': (object): The filters to apply, selected from the list below:
	//       * 'provider' (string): The provider like '"provider[\"registry.terraform.io/hashicorp/aws\"]"'
	//       * 'type'  (string): The type of the resource like 'aws_vpc'
	//       * 'name' (string): The name of the resource like 'front'
	//       * 'module' (string): The module name like 'module.lemp'
	//       * 'label' (string): The label of the resource, this only applies for resources created directly from the API/FE
	//       * 'attributes' (string): The query string to filter the attributes like 'ingress[0].protocol[eq]=tcp'
	//       * 'custom_attributes' (string): The query string to filter the custom_attributes like 'ingress[0].protocol[eq]=tcp'
	//       * 'project' (string): Linked project canonical
	//       * 'environment' (string): Linked environment canonical
	//       * 'component' (string): Linked component canonical
	//   * cy_inventory_output
	//     * 'attribute' (string): Path to the output's attribute, which value will be used
	//     * 'filters': (object): The filters to apply, selected from the list below:
	//       * 'attributes' (string): The query string to filter the attributes like 'ingress[0].protocol[eq]=tcp'
	//       * 'keys' (list(string)): List of output keys to select from
	//       * 'project' (string): Linked project canonical
	//       * 'environment' (string): Linked environment canonical
	//       * 'component' (string): Linked component canonical
	//       * 'service_catalogs' (list(string)): Linked service catalog (stack) canonicals
	WidgetConfig any `json:"widget_config,omitempty"`
}

// Validate validates this form entity
func (m *FormEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWidget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FormEntity) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *FormEntity) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var formEntityTypeTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["integer","float","string","array","boolean","map"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		formEntityTypeTypePropEnum = append(formEntityTypeTypePropEnum, v)
	}
}

const (

	// FormEntityTypeInteger captures enum value "integer"
	FormEntityTypeInteger string = "integer"

	// FormEntityTypeFloat captures enum value "float"
	FormEntityTypeFloat string = "float"

	// FormEntityTypeString captures enum value "string"
	FormEntityTypeString string = "string"

	// FormEntityTypeArray captures enum value "array"
	FormEntityTypeArray string = "array"

	// FormEntityTypeBoolean captures enum value "boolean"
	FormEntityTypeBoolean string = "boolean"

	// FormEntityTypeMap captures enum value "map"
	FormEntityTypeMap string = "map"
)

// prop value enum
func (m *FormEntity) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, formEntityTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FormEntity) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var formEntityTypeWidgetPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["auto_complete","dropdown","radios","slider_list","slider_range","number","simple_text","switch","text_area","cy_cred","cy_scs","cy_crs","cy_branch","cy_inventory_resource","cy_inventory_output","hidden"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		formEntityTypeWidgetPropEnum = append(formEntityTypeWidgetPropEnum, v)
	}
}

const (

	// FormEntityWidgetAutoComplete captures enum value "auto_complete"
	FormEntityWidgetAutoComplete string = "auto_complete"

	// FormEntityWidgetDropdown captures enum value "dropdown"
	FormEntityWidgetDropdown string = "dropdown"

	// FormEntityWidgetRadios captures enum value "radios"
	FormEntityWidgetRadios string = "radios"

	// FormEntityWidgetSliderList captures enum value "slider_list"
	FormEntityWidgetSliderList string = "slider_list"

	// FormEntityWidgetSliderRange captures enum value "slider_range"
	FormEntityWidgetSliderRange string = "slider_range"

	// FormEntityWidgetNumber captures enum value "number"
	FormEntityWidgetNumber string = "number"

	// FormEntityWidgetSimpleText captures enum value "simple_text"
	FormEntityWidgetSimpleText string = "simple_text"

	// FormEntityWidgetSwitch captures enum value "switch"
	FormEntityWidgetSwitch string = "switch"

	// FormEntityWidgetTextArea captures enum value "text_area"
	FormEntityWidgetTextArea string = "text_area"

	// FormEntityWidgetCyCred captures enum value "cy_cred"
	FormEntityWidgetCyCred string = "cy_cred"

	// FormEntityWidgetCyScs captures enum value "cy_scs"
	FormEntityWidgetCyScs string = "cy_scs"

	// FormEntityWidgetCyCrs captures enum value "cy_crs"
	FormEntityWidgetCyCrs string = "cy_crs"

	// FormEntityWidgetCyBranch captures enum value "cy_branch"
	FormEntityWidgetCyBranch string = "cy_branch"

	// FormEntityWidgetCyInventoryResource captures enum value "cy_inventory_resource"
	FormEntityWidgetCyInventoryResource string = "cy_inventory_resource"

	// FormEntityWidgetCyInventoryOutput captures enum value "cy_inventory_output"
	FormEntityWidgetCyInventoryOutput string = "cy_inventory_output"

	// FormEntityWidgetHidden captures enum value "hidden"
	FormEntityWidgetHidden string = "hidden"
)

// prop value enum
func (m *FormEntity) validateWidgetEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, formEntityTypeWidgetPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FormEntity) validateWidget(formats strfmt.Registry) error {

	if err := validate.Required("widget", "body", m.Widget); err != nil {
		return err
	}

	// value enum
	if err := m.validateWidgetEnum("widget", "body", *m.Widget); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this form entity based on context it is used
func (m *FormEntity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FormEntity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FormEntity) UnmarshalBinary(b []byte) error {
	var res FormEntity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
