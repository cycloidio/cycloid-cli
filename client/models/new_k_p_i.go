// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewKPI New KPI
//
// # A KPI's configuration that needs to be saved
//
// swagger:model NewKPI
type NewKPI struct {

	// canonical
	// Max Length: 100
	// Min Length: 3
	// Pattern: ^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$
	Canonical string `json:"canonical,omitempty"`

	// The config represent some extra parameters which are required for the configuration of certain KPIs. Please refer to the documentation for more details.
	//
	Config interface{} `json:"config,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// job name
	JobName string `json:"job_name,omitempty"`

	// name
	// Required: true
	// Min Length: 3
	Name *string `json:"name"`

	// pipeline name
	PipelineName string `json:"pipeline_name,omitempty"`

	// type
	// Required: true
	// Enum: ["build_avg_time","build_frequency","build_history","code_coverage","time_to_release"]
	Type *string `json:"type"`

	// widget
	// Required: true
	// Enum: ["bars","stackbars","doughnut","history","line","pie","summary"]
	Widget *string `json:"widget"`
}

// Validate validates this new k p i
func (m *NewKPI) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCanonical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWidget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NewKPI) validateCanonical(formats strfmt.Registry) error {
	if swag.IsZero(m.Canonical) { // not required
		return nil
	}

	if err := validate.MinLength("canonical", "body", m.Canonical, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("canonical", "body", m.Canonical, 100); err != nil {
		return err
	}

	if err := validate.Pattern("canonical", "body", m.Canonical, `^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$`); err != nil {
		return err
	}

	return nil
}

func (m *NewKPI) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 3); err != nil {
		return err
	}

	return nil
}

var newKPITypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build_avg_time","build_frequency","build_history","code_coverage","time_to_release"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		newKPITypeTypePropEnum = append(newKPITypeTypePropEnum, v)
	}
}

const (

	// NewKPITypeBuildAvgTime captures enum value "build_avg_time"
	NewKPITypeBuildAvgTime string = "build_avg_time"

	// NewKPITypeBuildFrequency captures enum value "build_frequency"
	NewKPITypeBuildFrequency string = "build_frequency"

	// NewKPITypeBuildHistory captures enum value "build_history"
	NewKPITypeBuildHistory string = "build_history"

	// NewKPITypeCodeCoverage captures enum value "code_coverage"
	NewKPITypeCodeCoverage string = "code_coverage"

	// NewKPITypeTimeToRelease captures enum value "time_to_release"
	NewKPITypeTimeToRelease string = "time_to_release"
)

// prop value enum
func (m *NewKPI) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, newKPITypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NewKPI) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var newKPITypeWidgetPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bars","stackbars","doughnut","history","line","pie","summary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		newKPITypeWidgetPropEnum = append(newKPITypeWidgetPropEnum, v)
	}
}

const (

	// NewKPIWidgetBars captures enum value "bars"
	NewKPIWidgetBars string = "bars"

	// NewKPIWidgetStackbars captures enum value "stackbars"
	NewKPIWidgetStackbars string = "stackbars"

	// NewKPIWidgetDoughnut captures enum value "doughnut"
	NewKPIWidgetDoughnut string = "doughnut"

	// NewKPIWidgetHistory captures enum value "history"
	NewKPIWidgetHistory string = "history"

	// NewKPIWidgetLine captures enum value "line"
	NewKPIWidgetLine string = "line"

	// NewKPIWidgetPie captures enum value "pie"
	NewKPIWidgetPie string = "pie"

	// NewKPIWidgetSummary captures enum value "summary"
	NewKPIWidgetSummary string = "summary"
)

// prop value enum
func (m *NewKPI) validateWidgetEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, newKPITypeWidgetPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NewKPI) validateWidget(formats strfmt.Registry) error {

	if err := validate.Required("widget", "body", m.Widget); err != nil {
		return err
	}

	// value enum
	if err := m.validateWidgetEnum("widget", "body", *m.Widget); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this new k p i based on context it is used
func (m *NewKPI) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NewKPI) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NewKPI) UnmarshalBinary(b []byte) error {
	var res NewKPI
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
