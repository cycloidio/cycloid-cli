// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ServiceCatalog Service Catalog
//
// # Represents the Service Catalog item
//
// swagger:model ServiceCatalog
type ServiceCatalog struct {

	// author
	// Required: true
	Author *string `json:"author"`

	// Determines if given stack is a blueprint
	Blueprint bool `json:"blueprint,omitempty"`

	// canonical
	// Required: true
	// Max Length: 100
	// Min Length: 3
	// Pattern: ^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$
	Canonical *string `json:"canonical"`

	// Cloud providers supported by the stack
	CloudProviders []*CloudProvider `json:"cloud_providers"`

	// created at
	// Minimum: 0
	CreatedAt *uint64 `json:"created_at,omitempty"`

	// dependencies
	Dependencies []*ServiceCatalogDependency `json:"dependencies"`

	// description
	Description string `json:"description,omitempty"`

	// Directory where the ServiceCatalog configuration is found.
	// Required: true
	Directory *string `json:"directory"`

	// Indicates if this stack can be configured with form's or not. Based on the presence or not of a valid .forms.yaml file since it's creation or last refresh.
	// Required: true
	FormEnabled *bool `json:"form_enabled"`

	// id
	// Required: true
	// Minimum: 1
	ID *uint32 `json:"id"`

	// image
	// Format: uri
	Image strfmt.URI `json:"image,omitempty"`

	// The import process status.
	// Enum: ["succeeded","failed","importing"]
	ImportStatus string `json:"import_status,omitempty"`

	// keywords
	// Required: true
	Keywords []string `json:"keywords"`

	// Indicates if the stack uses the latest version
	// Required: true
	Latest *bool `json:"latest"`

	// name
	// Required: true
	Name *string `json:"name"`

	// Organization that the stack belongs to
	// Required: true
	// Max Length: 100
	// Min Length: 3
	// Pattern: ^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$
	OrganizationCanonical *string `json:"organization_canonical"`

	// Indicates if this stack can be configured with form's and has a Quota configuration.
	// Required: true
	QuotaEnabled *bool `json:"quota_enabled"`

	// Readme of the stack
	Readme string `json:"readme,omitempty"`

	// ref
	// Required: true
	Ref *string `json:"ref"`

	// service catalog source canonical
	// Max Length: 100
	// Min Length: 3
	// Pattern: ^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$
	ServiceCatalogSourceCanonical string `json:"service_catalog_source_canonical,omitempty"`

	// Team that maintains the stack
	Team *SimpleTeam `json:"team,omitempty"`

	// technologies
	Technologies []*ServiceCatalogTechnology `json:"technologies"`

	// If 'true' the ServiceCatalog is from the main organization and can be trusted.
	// Required: true
	Trusted *bool `json:"trusted"`

	// updated at
	// Minimum: 0
	UpdatedAt *uint64 `json:"updated_at,omitempty"`

	// Version of the stack
	// Required: true
	Version *string `json:"version"`

	// visibility
	// Required: true
	Visibility *string `json:"visibility"`
}

// Validate validates this service catalog
func (m *ServiceCatalog) Validate(formats strfmt.Registry) error {
	// Skip validation for blueprints entirely since they may contain templating strings
	if m.Blueprint {
		return nil
	}

	var res []error

	if err := m.validateAuthor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCanonical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudProviders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImportStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeywords(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganizationCanonical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuotaEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceCatalogSourceCanonical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTechnologies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrusted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServiceCatalog) validateAuthor(formats strfmt.Registry) error {

	if err := validate.Required("author", "body", m.Author); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateCanonical(formats strfmt.Registry) error {

	if err := validate.Required("canonical", "body", m.Canonical); err != nil {
		return err
	}

	if err := validate.MinLength("canonical", "body", *m.Canonical, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("canonical", "body", *m.Canonical, 100); err != nil {
		return err
	}

	if err := validate.Pattern("canonical", "body", *m.Canonical, `^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$`); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateCloudProviders(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudProviders) { // not required
		return nil
	}

	for i := 0; i < len(m.CloudProviders); i++ {
		if swag.IsZero(m.CloudProviders[i]) { // not required
			continue
		}

		if m.CloudProviders[i] != nil {
			if err := m.CloudProviders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloud_providers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloud_providers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ServiceCatalog) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.MinimumUint("created_at", "body", *m.CreatedAt, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateDependencies(formats strfmt.Registry) error {
	if swag.IsZero(m.Dependencies) { // not required
		return nil
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ServiceCatalog) validateDirectory(formats strfmt.Registry) error {

	if err := validate.Required("directory", "body", m.Directory); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateFormEnabled(formats strfmt.Registry) error {

	if err := validate.Required("form_enabled", "body", m.FormEnabled); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MinimumUint("id", "body", uint64(*m.ID), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateImage(formats strfmt.Registry) error {
	if swag.IsZero(m.Image) { // not required
		return nil
	}

	if err := validate.FormatOf("image", "body", "uri", m.Image.String(), formats); err != nil {
		return err
	}

	return nil
}

var serviceCatalogTypeImportStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["succeeded","failed","importing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serviceCatalogTypeImportStatusPropEnum = append(serviceCatalogTypeImportStatusPropEnum, v)
	}
}

const (

	// ServiceCatalogImportStatusSucceeded captures enum value "succeeded"
	ServiceCatalogImportStatusSucceeded string = "succeeded"

	// ServiceCatalogImportStatusFailed captures enum value "failed"
	ServiceCatalogImportStatusFailed string = "failed"

	// ServiceCatalogImportStatusImporting captures enum value "importing"
	ServiceCatalogImportStatusImporting string = "importing"
)

// prop value enum
func (m *ServiceCatalog) validateImportStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serviceCatalogTypeImportStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServiceCatalog) validateImportStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ImportStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateImportStatusEnum("import_status", "body", m.ImportStatus); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateKeywords(formats strfmt.Registry) error {

	if err := validate.Required("keywords", "body", m.Keywords); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateLatest(formats strfmt.Registry) error {

	if err := validate.Required("latest", "body", m.Latest); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateOrganizationCanonical(formats strfmt.Registry) error {

	if err := validate.Required("organization_canonical", "body", m.OrganizationCanonical); err != nil {
		return err
	}

	if err := validate.MinLength("organization_canonical", "body", *m.OrganizationCanonical, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("organization_canonical", "body", *m.OrganizationCanonical, 100); err != nil {
		return err
	}

	if err := validate.Pattern("organization_canonical", "body", *m.OrganizationCanonical, `^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$`); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateQuotaEnabled(formats strfmt.Registry) error {

	if err := validate.Required("quota_enabled", "body", m.QuotaEnabled); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateRef(formats strfmt.Registry) error {

	if err := validate.Required("ref", "body", m.Ref); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateServiceCatalogSourceCanonical(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceCatalogSourceCanonical) { // not required
		return nil
	}

	if err := validate.MinLength("service_catalog_source_canonical", "body", m.ServiceCatalogSourceCanonical, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("service_catalog_source_canonical", "body", m.ServiceCatalogSourceCanonical, 100); err != nil {
		return err
	}

	if err := validate.Pattern("service_catalog_source_canonical", "body", m.ServiceCatalogSourceCanonical, `^[a-z0-9]+[a-z0-9\-_]+[a-z0-9]+$`); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateTeam(formats strfmt.Registry) error {
	if swag.IsZero(m.Team) { // not required
		return nil
	}

	if m.Team != nil {
		if err := m.Team.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("team")
			}
			return err
		}
	}

	return nil
}

func (m *ServiceCatalog) validateTechnologies(formats strfmt.Registry) error {
	if swag.IsZero(m.Technologies) { // not required
		return nil
	}

	for i := 0; i < len(m.Technologies); i++ {
		if swag.IsZero(m.Technologies[i]) { // not required
			continue
		}

		if m.Technologies[i] != nil {
			if err := m.Technologies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("technologies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("technologies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ServiceCatalog) validateTrusted(formats strfmt.Registry) error {

	if err := validate.Required("trusted", "body", m.Trusted); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.MinimumUint("updated_at", "body", *m.UpdatedAt, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *ServiceCatalog) validateVisibility(formats strfmt.Registry) error {

	if err := validate.Required("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this service catalog based on the context it is used
func (m *ServiceCatalog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCloudProviders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDependencies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTeam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTechnologies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServiceCatalog) contextValidateCloudProviders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CloudProviders); i++ {

		if m.CloudProviders[i] != nil {

			if swag.IsZero(m.CloudProviders[i]) { // not required
				return nil
			}

			if err := m.CloudProviders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloud_providers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloud_providers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ServiceCatalog) contextValidateDependencies(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Dependencies); i++ {

		if m.Dependencies[i] != nil {

			if swag.IsZero(m.Dependencies[i]) { // not required
				return nil
			}

			if err := m.Dependencies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ServiceCatalog) contextValidateTeam(ctx context.Context, formats strfmt.Registry) error {

	if m.Team != nil {

		if swag.IsZero(m.Team) { // not required
			return nil
		}

		if err := m.Team.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("team")
			}
			return err
		}
	}

	return nil
}

func (m *ServiceCatalog) contextValidateTechnologies(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Technologies); i++ {

		if m.Technologies[i] != nil {

			if swag.IsZero(m.Technologies[i]) { // not required
				return nil
			}

			if err := m.Technologies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("technologies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("technologies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServiceCatalog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServiceCatalog) UnmarshalBinary(b []byte) error {
	var res ServiceCatalog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainsTemplatingInAnyField checks if any field in the ServiceCatalog contains templating strings
func (m *ServiceCatalog) ContainsTemplatingInAnyField() bool {
	// Check string pointer fields
	if m.Author != nil && containsTemplatingString(*m.Author) {
		return true
	}
	if m.Canonical != nil && containsTemplatingString(*m.Canonical) {
		return true
	}
	if m.Directory != nil && containsTemplatingString(*m.Directory) {
		return true
	}
	if m.Name != nil && containsTemplatingString(*m.Name) {
		return true
	}
	if m.OrganizationCanonical != nil && containsTemplatingString(*m.OrganizationCanonical) {
		return true
	}
	if m.Ref != nil && containsTemplatingString(*m.Ref) {
		return true
	}
	if m.Version != nil && containsTemplatingString(*m.Version) {
		return true
	}
	if m.Visibility != nil && containsTemplatingString(*m.Visibility) {
		return true
	}

	// Check regular string fields
	if containsTemplatingString(m.Description) {
		return true
	}
	if containsTemplatingString(m.ImportStatus) {
		return true
	}
	if containsTemplatingString(m.Readme) {
		return true
	}
	if containsTemplatingString(m.ServiceCatalogSourceCanonical) {
		return true
	}

	// Check URI field
	if !swag.IsZero(m.Image) && containsTemplatingString(m.Image.String()) {
		return true
	}

	// Check keywords array
	for _, keyword := range m.Keywords {
		if containsTemplatingString(keyword) {
			return true
		}
	}

	return false
}

// containsTemplatingString checks if the string contains blueprint templating syntax like ($> <$) or ($ $)
func containsTemplatingString(s string) bool {
	// Match patterns like ($> ... <$) or ($ ... $) etc.
	for i := 0; i < len(s)-1; i++ {
		if s[i] == '(' && s[i+1] == '$' {
			// Look for closing $)
			for j := i + 2; j < len(s)-1; j++ {
				if s[j] == '$' && s[j+1] == ')' {
					return true
				}
			}
		}
	}
	return false
}
