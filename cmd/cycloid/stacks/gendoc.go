package stacks

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"sort"
	"text/template"

	"github.com/cycloidio/cycloid-cli/client/models"
	"github.com/cycloidio/cycloid-cli/cmd/cycloid/common"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

var (
	document = `
{{ range . }}
## Usecase: {{ .Name }}

{{ range .Technologies }}
### {{ .Name }}

{{ range .Sections }}
#### {{ .Name }}

| Parameter Name | Description |Type | Default |
|----------------|-------------|-----|---------|
{{ range .Parameters -}}
| {{ .Key }}  | {{ .Description}} |{{ .Type }} | {{ .Default }} |
{{ end }}
{{ end }}
{{ end }}
{{ end }}
_Generated by [cycloid-cli](https://github.com/cycloidio/cycloid-cli)_
`
)

// Usecase of the forms, default is `default` one
type Usecase struct {
	// Name is the name of the usecase
	Name string
	// Technologies holds the list
	// of technologies in the stackforms
	Technologies []Technology
}

// Technology is the technology described
// in the stack forms (e.g: terraform, pipeline, etc.)
type Technology struct {
	// Name is the name of the technology
	Name string
	// Sections holds the list
	// of sections in the technologoy
	Sections []Section
}

// Section is the section described in the technology
// (e.g: ec2, network, etc.)
type Section struct {
	// Name is the name of the section
	Name string
	// Parameters holds the list
	// of the parameter in the section
	Parameters []Parameter
}

// Parameter is the parameter described in the the section
// (e.g: required: true, type: string, etc.)
type Parameter struct {
	// Key of the parameter
	Key string
	// Type of the parameter
	Type string
	// Default value, currently supported: string / integer
	Default interface{}
	// Description is the parameter description
	Description string
}

// NewGendDocCmd returns the cobra command holding
// the forms gen-doc subcommand
func NewGenDocCmd() *cobra.Command {
	var cmd = &cobra.Command{
		Use:   "gen-doc",
		Short: "generate a markdown file from stackforms",
		Long:  "generate a markdown file from stackforms in order to create documentation for a README in example",
		Example: `
	# generate a stackforms file documentation
	cy stacks gen-doc --forms .forms.yml > README.md
		`,
		RunE: func(cmd *cobra.Command, args []string) error {
			formPath, err := cmd.Flags().GetString("forms")
			if err != nil {
				return fmt.Errorf("unable to get forms flag")
			}
			return GenerateDoc(formPath, os.Stdout)
		},
	}

	common.RequiredPersistentFlag(WithFlagForms, cmd)

	return cmd
}

// GenerateDoc is the method used to generate documentation
// from a stackform
func GenerateDoc(formPath string, w io.Writer) error {
	var (
		f        models.FormsFile
		usecases []Usecase = make([]Usecase, 0)
		t                  = template.Must(template.New("document").Parse(document))
	)

	rawForms, err := ioutil.ReadFile(formPath)
	if err != nil {
		return fmt.Errorf("unable to read the form file: %w", err)
	}

	if err := yaml.Unmarshal(rawForms, &f); err != nil {
		return fmt.Errorf("unable to unmarshal form file content: %w", err)
	}

	// we first build a slice of usecases
	for usecase, technologies := range f {
		techs := make([]Technology, 0)
		for techName, sections := range technologies {
			s := make([]Section, 0)
			for sectionName, parameters := range sections {
				p := make([]Parameter, 0)
				for _, parameter := range parameters {
					param := Parameter{
						Key:         "n/a",
						Default:     "n/a",
						Type:        "n/a",
						Description: parameter.Description,
					}
					if parameter.Key != nil {
						param.Key = *parameter.Key
					}
					if parameter.Type != nil {
						param.Type = *parameter.Type
					}

					switch parameter.Default.(type) {
					case string:
						param.Default = parameter.Default.(string)
					case int:
						param.Default = parameter.Default.(int)
					}
					p = append(p, param)
				}
				s = append(s, Section{
					Name:       sectionName,
					Parameters: p,
				})
			}
			sort.Slice(s, func(i, j int) bool { return s[i].Name < s[j].Name })
			techs = append(techs, Technology{
				Name:     techName,
				Sections: s,
			})
		}
		sort.Slice(techs, func(i, j int) bool { return techs[i].Name < techs[j].Name })
		usecases = append(usecases, Usecase{Name: usecase, Technologies: techs})
	}
	// we could stop here and render the template
	// but we rely on a map[string]... so the order
	// won't be the same between each run, we could potentially be
	// annoying.
	// let's sort the slice
	sort.Slice(usecases, func(i, j int) bool { return usecases[i].Name < usecases[j].Name })

	if err := t.Execute(w, usecases); err != nil {
		return fmt.Errorf("unable to render documentation template: %w", err)
	}

	return nil
}
